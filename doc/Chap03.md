# Chap03 인스턴스 & 컴포넌트
* 목표
    - 구조적으로 UI를 설계하기 위해서는 왜 컴포넌트가 필요한지 알아보자.
    - 화면을 그리기 위해서는 왜 인스턴스가 있어야 하는지 알아보자.
### 1. 뷰 인스턴스
1. 뷰 인스턴스의 정의와 속성
    - 정의: 뷰 인스턴스는 뷰로 화면을 개발하기 위해 필수적으로 생성해야 하는 기본 단위이다.

    - 뷰 인스턴스 생성
        - 뷰 인스턴스를 사용하기 위해 아래와 같은 형식으로 뷰 인스턴스를 생성한다.
        - 인스턴스 형식
        
        ```javascript
        new Vue({
            ...
        });
        ```
        - Chap03/helloVue.html 참조
    - 뷰 인스턴스 생성자
        - new Vue()로 인스턴스를 생성할 때 Vue를 생성자라고 합니다.
        - Vue 생성자는 뷰 라이브러리를 로딩하고 나면 접근할 수 있습니다.
        - 생성자를 사용하는 이유는 뷰로 개발할 때 필요한 기능들을 생성자에 미리 정의해 놓고 사용자가 그 기능을 재정의하여 편리하게 사용하도록 하기 위해서입니다.

2. 뷰 인스턴스 옵션 속성
    - 뷰 인스턴스 옵션 속성은 인스턴스를 생성할 때 재정의할 `data`, `el`, `template` 등의 속성을 의미한다.
        - `data`: 
        - `el`:
        - `template`:
        - `methods`:
        - `created`:

3. 뷰 인스턴스의 유효범위
    - 인스턴스의 유효 범위란?
        - 뷰 인스턴스를 생성하면 HTML의 특정 범위 안에서만 옵션 속성들이 적용되어 나타납니다. 이를 인스턴스의 유효 범위라고 합니다.
        - 지역 컴포넌트와 전역 컴포넌트의 차이점을 이해하기 위해서도 꼭 알아야 하는 개념이며, 인스턴스의 유효 범위는 el속성과 밀접한 관계가 있습니다.
        .
        - 인스턴스의 유효 범위를 이해하려면 인스턴스가 생성된 후 화면에 어떻게 적용되는지 알아야 합니다.
        - `new Vue()`로 인스턴스를 생성하고 나서 화면에 인스턴스 옵션 속성을 적용하는 과정은 다음과 같습니다.
        .
        - 뷰 라이브러리 파일 로딩 -> 인스턴스 객체 생성(옵션 속성 포함) -> 특정 화면 요소를 인스턴스를 붙임 -> 인스턴스 내용이 화면 요소로 변환 -> 변환된 화면 요소를 사용자가 최종 확인

    - 인스턴스의 유효 범위 확인
        - 그런데 만약 인스턴스의 유효범위를 벗어나면 어떻게 될까?
        - 인스턴스의 유효 범위를 벗어나 선언한 message
        
        ```javascript
        // 인스턴스의 유효 범위 시작
        <div id="app">
        
        </div>
        // 인스턴스의 유효 범위 끝
        {{ message }}
        ```

        - message 속성의 값이 Hello Vue.js!로 바뀌지 않고 그대로 출력되는 이유는 인스턴스의 유효 범위 때문입니다.
        - 현재 코드에서 인스턴스의 유효 범위는 el 속성으로 지정한 `<div id="app">`태그 아래에 오는 요소들로 제한됩니다.
        - 따라서 `<div>` 태그 바깥에 있는 `{{ message }}`는 뷰에서 인식하지 못 하기 때문에 Hello Vue.js!로 바뀌지 않고 `{{ message }}` 그래로 출력됩니다.

4. 뷰 인스턴스 라이프 사이클
    - 인스턴스의 상태에 따라 호출할 수 있는 속성들을 라이프 사이클(life cycle)속성이라고 합니다. 
    - 그리고 각 라이프 사이클 속성에서 실행되는 커스텀 로직을 라이프 사이클 훅(hook)이라고 합니다.

    - 용어) 라이프 사이클: 모바일 앱을 비롯하여 일반적으로 애플리케이션이 가지는 생명 주기
    - 용어) 커스텀 로직: 개발자가 임의로 작성한 로직

    - 라이프 사이클 속성에는 created, beforeCreate, beforeMount, mounted 등 인스턴스의 생성, 변경, 소멸과 관련괴어 총 8개가 있습니다.

    그림

    - 이 그림은 인스턴스가 생성되고 나서 화면에 인스턴스가 부착된 후 소멸되기까의 전체적인 흐름을 나타낸 뷰 인스턴스 라이프 사이클 다이어그램입니다.

    - 라이프 사이클 단계를 크게 나누면 인스턴스의 **생성**, 생성된 인스턴스를 화면에 **부착**, 화면에 부착된 인스턴스의 내용이 **갱신**, 인스턴스가 제거되는 **소멸**의 4단계로 이루어집니다.
    - 위 그림에서 부착 -> 갱신 구간은 데이터가 변경되는 경우에만 거치게 됩니다.
    - 그리고 각 단계 사이에 라이프 사이클 속성 created, mounted, updated 등이 실행됩니다.

    1. **beforeCreate**
        - 인스턴스가 생성되고 나서 가장 처음으로 실행되는 라이프 사이클 단계입니다. 
        - 이 단계에서는  data 속성과 methods 속성이 아직 인스턴스에 정의되어 있지 않고, 돔과 같은 화면 요소에도 접근할 수 없습니다.
    2. **created**
        - beforeCreate 라이프 사이클 단계 다음에 실행되는 단계입니다. 
        - `data` 속성과 `methods` 속성이 정의 되었기 때문에 `this.data` 또는 `this.fetchData()`와 같은 로직들을 이용하여 `data` 속성과 `methods `속성에 정의된 값에 접근하여 로직을 실행할 수 있습니다.
        - 다만, 아직 인스턴스가 화면 요소에 부착되기 전이기 때문에 `template` 속성에 정의된 돔 요소로 접근할 수 없습니다.

        - 그리고 `data` 속성과 `methods` 속성에 접근할 수 있는 가장 첫 라이프 사이클 단계이자 컴포넌트가 생성되고 나서 실행되는 단계이기 때문에 서버에 데이터를 요청하여 받아오는 로직을 수행하기 좋습니다.
    3. beforeMount
        - created 단계 이후 template 속성에 지정한 마크업 속성을 render()함수로 변환한 후 el 속성에 지정한 화면 요소(돔)에 인스턴스를 부착하기 전에 호출되는 단계입니다. 
        - render() 함수가 호출되기 직전의 로직을 추가하기 좋습니다.
    4. **mounted**
        - el 속성에서 지정한 화면 요소에 인스턴스가 부착되고 나면 호출되는 단계로, template 속성에 정의한 화면 요소(돔)에 접근할 수 있어 화면 요소를 제어하는 로직을 수행하기 좋은 단계입니다.
        - 다만, 돔에 인스턴스가 부착되자마자 바로 호출되기 때문에 하위 컴포넌트나 외부 라이브러리에 의해 추가된 화면 요소들이 최종 HTML 코드로 변화되는 시점과 다를 수 있습니다.
    5. beforeUpdate
        - el 속성에서 지정한 화면 요소에 인스턴스가 부착되고 나면 인스턴스에 정의한 속성들이 화면에 치환됩니다.
        - 치환된 값은 뷰의 반응성(Reactivity)을 제공하기 위해 $watch 속성으로 감시합니다.
        - 이를 데이터 관찰이라고 합니다.

        - 또한 beforeUpdate는 관찰하고 있는 데이터가 변경되면 가상 돔으로 화면을 다시 그리기 전에 호출되는 단계이며, 변경 예정인 새 데이터에 접근할 수 있어 변경 예정 데이터의 값과 관련된 로직을 미리 넣을 수 있습니다.
        -  만약 여기에 값을 변경화는 로직을 넣더라도 화면이 다시 그려지지는 않습니다.
    6. **updated**
        - 데이터가 변경되고 나서 가상 돔으로 다시 화면을 그리고 나면 실행되는 단계입니다. - 데이터 변경으로 인한 화면 요소 변경까지 완료된 시점이므로, 데이터 변경 후 화면 요소 제어와 관련된 로직을 추가하기 좋은 단계입니다.
        - 이 단계에서 데이터 값을 변경하면 무한 루프에 빠질 수 있기 때문에 값을 변경하려면 computed, watch와 같은 속성을 사용해야 합니다.
        - 따라서 데이터 값을 갱신하는 로직은 가급적이면 beforeUpdate에 추가하고, updated에서는 변경 데이터의 화면 요소(돔)와 관련된 로직을 추가하는 것이 좋습니다.
    7. beforeDestroy
        - 뷰 인스턴스가 파괴되기 직전에 호출되는 단계입니다. 이 단계에서는 아직 인스턴스에 접근할 수 있습니다. 따라서 뷰 인스턴스의 데이터를 삭제하기 좋은 단계입니다.
    8. destroyed
        - 뷰 인스턴스가 파괴되고 나서 호출되는 단계입니다. 뷰 인스턴스에 정의한 모든 속성이 제거되고 하위에 선언한 인스턴스들 또한 모두 파괴됩니다.

    - 참고 Chap03\lifecycle.html
    - 뷰를 재대로 사용하려면 지금까지 배운 뷰 인스턴스 라이프 사이클을 잘 익혀 두어야 합니다.
### 2. 뷰 컴포넌트
1. 컴포넌트란?
    - 조합하여 화면을 구성할 수 있는 블록(화면의 특정 영역)을 의미합니다.
    - 컴포넌트를 활용하면 화면을 빠르게 구조화하여 일괄적인 패턴으로 개발 할 수 있습니다.
    - 이렇게 화면의 영역을 컴포넌트로 쪼개서 재활용할 수 있는 형태로 관리하면 나중에 코드를 다시 사용하기가 훨씬 편리합니다.
    - 또한 모든 사람들이 정해진 방식대로 컴포넌트르 등록하거나 사용하게 되므로 남이 작성한 코드를 직관적으로 이해할 수 있습니다.
    - 뷰에서는 웹 화면을 구성할 때 흔히 사용하는 내비게이션 바, 테이블, 리스트, 인풋 박스 등과 같은 화면 구성요소들을 잘게 쪼개어 컴포넌트롤 관리합니다.

    그림

    - 위의 왼쪽 그림은 화면 전체를 Header, Content, Footer로 분할하였고, Content 영역을 Aside, List 영역으로 분할하였습니다. 
    - 이는 화면 전체를 3개의 컴포넌츠로 분할한 후 분할된 1개의 컴포넌트에서 다시 2개의 하위 컴포넌트로 분할 한 것입니다.
    - 그리고 오른쪽 그림은 각 컴포너트 간의 관계를 나타냅니다.
    - 이러한 컴포넌트 간의 관계는 뷰에서 화면을 구성하는 데 매우 중요한 역할을 하며, 웹 페이지 화면을 설계할 때도 이와 같은 골격을 유지하면서 설계를 해야 합니다.
    - 참고로 컴포넌트 간의 관계는 자료구조의 트리(Tree)모양과 유사합니다.
2. 컴포넌트 등록하기
    - 컴포넌트를 등록하는 방법은 전역과 지역의 두 가지가 있습니다.
    - 지역(Local) 컴포넌트는 특정 인스턴스에서만 유효한 범위를 갖고, 전역(Global) 컴포넌트는 여러 인스턴스에서 공통으로 사용할 수 있습니다.

    1. 전역 컴포넌트 등록
        - 전역 컴포넌트는 뷰 라이브러리를 로딩하고 나면 접근 가능한 Vue 변수를 이용하여 등록합니다.
        - 전역 컴포넌트를 모든 인스턴스에 등록하려면 Vue 생성자에서 .component()를 호출하여 수행하면 됩니다.

        ```javascript
            Vue.component('컴포넌트 이름', {
                // 컴포넌트 내용
            });
        ```

        - 전역 컴포넌트 등록 형식에는 컴포넌트 이름과 컴포넌트 내용이 있습니다.
        - **컴포넌트 이름**은 template 속성에서 사용할 HTML 사용자 정의 태그(custom tag)이름을 의미합니다.
        - 태그 이름의 명명 규칙은 HTML 사용자 정의 태그 스펙에서 강제하는 '모두 소문자'와 '케밥 기법'을 따르지 않아도 됩니다.

        - 그리고 컴포넌트 태그가 실제 화면의 HTML 요소로 변환될 때 표시될 속성들을 **컴포넌트 내용**에 작성합니다.
        - 컴포넌트 내용에는 template, data, methods 등 인스턴스 옵션 속성을 정의 할 수 있습니다.

        - 참고 Chap03\component.html

        - 전역 컴포넌트가 화면에 나타나기까지의 처리 과정
        - 뷰 라이브러리 파일 로딩 -> 뷰 생성자로 컴포넌트 등록 Vue.component() -> 인스턴스 객체 생성(옵션 속성 포함) -> 특정 화면 요소에 인스턴스 부착 -> 인스턴스 내용 변환(등록된 컴포넌트 내용도 변환) // `<my-component>`가 `<div>`로 변환됨 -> 변환된 화면 요소를 사용자가 최종 확인
    2. 지역 컴포넌트 등록
        - 전역 컴포넌트 등록과는 다르게 인스턴스에 components 속성을 추가하고 등록할 컴포넌트 이름과 내용을 정의하면 됩니다.
        
        - 지역 컴포넌트 등록 형식

        ```javascript
        new Vue({
            components: {
                '컴포넌트 이름' : 컴포넌트 내용
            }
        });
        ```
        - 컴포넌트 이름은 전역 컴포넌트와 마찬가지로 HTML에 등록할 사용자 정의 태그를 의미하고, 컴포넌트 내용는 컴포넌트 태그가 실제 화면 요소로 변환될 때의 내용을 의미합니다.
        
        - 참고 Chap03\component2.html
3. 지역 컴포넌트와 전역 컴포넌트의 차이
    - 지역 컴포넌트와 전역 컴포넌트의 차이점을 이해하기 위해서는 앞에서 배운 인스턴스의 유효 범위를 이해해야 합니다. 인스턴스의 유효 범위란 HTML의 특정 범위 안에서만 인스턴스의 내용이 유효한 것이라고 했는데, 그럼 다음코드를 살펴볼까요?
    
    - 참고 Chap03\component3.html

    - 첫번째 인스턴스 영역에는 전역, 지역 컴포넌트가 모두 정상적으로 나타났습니다. 하지만 구분선 밑에 두번째 인스턴스 영역에는 전역 컴포넌트만 나타나고, 지역 컴포넌트는 나타나지 않았습니다. 왜 그럴까요? **전역 컴포넌트와 지역 컴포넌트의 유효 범위가 다르기 때문입니다.**

    - 전역 컴포넌트는 인스턴스를 새로 생성할 때마다 인스턴스에 components속성으로 등록할 필요 없이 한 번 등록하면 어느 인스턴스에서든 사용할 수 있습니다.
    - 반대로 지역 컴포넌트는 새 인스턴스를 생성할 때마다 등록해 줘야 합니다.

    - 그리고 '3-1 뷰 인스턴스의 유효범위'에서 설명한 인스턴스의 범위도 여기에 적용됩니다.
    - 첫 번째  인스턴스 유효 범위는 첫번째 인스턴스 영역으로 제한 되기 때문에 `<div id="app">`에 지역 컴포넌트를 등록했어도 두번째 인스턴스 영역인 `<div id="app2">`의 범위 안에서는 지역 컴포넌트가 인식되지 않아 아래와 같은 결과를 나타냅니다.

    그림

    - `<my-local-component>`태그는 두번째 인스턴스의 유효 범위 안에 있더라도 이 컴포넌트가 등록된 첫번째 유효 범위를 벗어나기 때문데 브라우저에서는 HTML 사용자 정의 태그로 인식하고, 뷰에서는 해당 컴포넌트를 제대로 등록했는지 물어보는 오류를 표시합니다.

    - 참고 오류를 해결하려면 지역 컴포넌트에 components속성을 추가하여 다시 실행하면 됩니다.